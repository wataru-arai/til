# 学習ノート
## 2025/01/26
- 『WEB+DB PRESS Vol.127 リファクタリング』を読んだ
  - 結合度とか凝集度について[ここ](https://gist.github.com/wataru-arai/f3b72dd604d753915019b47b12aa8d35)で触れたけどうまいこと説明できる自信がなかったので学び直し
- 凝集度
  - 関数の役割・機能の少なさ
  - 役割が少ないほど凝集度が高い・役割が多いと凝集度が低い
  - 「単一の機能」をどう捉えるかで認識が食い違うことがありそうな気がする
    - 機能をユースケースや目的、と言い換えてもいいのかもしれない
- 結合度
  - （2つ以上の関数における）独立性
  - 独立しているほど結合度が低い・していないと結合度が高い
-
- コードだけではなくアーキテクチャの検討の基準にも使える概念
- 共通化による変更箇所の局所化 vs 論理的凝集
  - 受託開発をやっていると前者が肯定されがちな気がする（短期的なスピードによるスケジュール充足がゴールになるので）
  - 論理的な凝集を選択する根拠は将来の変更に対応するためだと思うけど、その「将来の変更がどれくらいあるの？」と聞かれると答えに窮してしまう感覚がある
    - どちらかというと、「早まった抽象化を避けよう」という呼びかけをした方が良さそうな気がする
- 論理的凝集はPRレビューしててもよく見る気がする
  - 外部に公開するメソッドを1つにしたいとかそういう理由で実装されているようなイメージ
  - フラグを渡したり型を判定したりして分岐しているなら論理的凝集ということかも
    - 「フラグ引数はアンチパターンだよね」といった方が伝わるような気がする
- 受託みたいな開発をしているかどうかで許容されるコードの形は変わりそうな気もする
- まとめ
  - まず「高凝集・低結合を目指してコードを書く」ということが目指すべき方向
  - 論理的凝集に対してはテストによる変更漏れの回避・単一責任の原則あたりがアンサーになるかも
  - DRYについては「フラグ引数はアンチパターンだよね」的なアンサーがあるかも あとは「早まった抽象化を避けよう・フィードバックを得よう」とかも
  - 前提として、開発の生産性の評価というものが必要かもしれない


## 2025/01/24
- 『Software Design 2024年9月号 GraphQLでアプリケーション開発』を読んだ
  - GraphQLの利点を質問されてうまく説明できなかったので、手元に買っておいたこの本を読んだ
- GraphQLの利点
  - 通信量の効率化
    - オーバー・アンダーフェッチを回避して必要なデータだけを取得できる
    - ユースケースベース（リソースベースではない）のREST API設計・BFFでもできないことはないが、比較して導入しやすい
  - コンポーネント指向のUI設計が可能になる
  - 型システムの恩恵を受けられる
  - 漸進的なAPIの発展が可能になる
- ついでに内部向けのGraphQL APIを開発しているが、PersistedQueryやSingedQueryについては知らなかった
  - TrustedDocumentを利用することでセキュリティ向上と利用状況の収集による安全なAPIバージョンアップを実現することができるとのこと

## 2025/01/23
- 昨日のTypeScriptの話、Rubocopとほぼ同じことしてることに気づいた
  - カスタムRubocopの作り方を調べている時に気がついた
  - Prismとかもこの関連の話なんだろうなと思い、ConnectingDotsしてきた感がある
- 『ラムダノート 型を活用した安全なアプリケーション開発』を読んだ
  - コンパイル時点で不可能な操作が検知できるのは体験として良さそうな気がする
    - 型のないRailsでテストコードを書きまくってると、どうしてもコード量が大きくなってしまい見通しが悪くなりがち
    - Railsだと特定のモデルにビジネスロジックが集中するので、そのモデルのコードを読まないとビジネスロジックの内容がわからないというのがありそう
      - ルールを型で表現することで、ルールを遵守させる強制力が生まれそう
  - こうなってくると型のある開発では状態ではなく振る舞いに対してテスト書く感じになるんだろうか
    - 何だかよくわからなくなってきた感もある

## 2025/01/22
- ラムダノート TypeScriptではじめる型システムを読む
- TypeScriptの構文から構文木を組み立ててそれをさらに型付けして安全性をチェックする、という話だった
  - 構文木というのはようは木構造のデータ構造ということだと思う
  - 何かを解析する・処理するってことはまずは適したデータ構造に落とし込むということなんだなと思う
  - 木構造すると再帰の構造が生まれて、プログラミングで処理しやすくなる 気がする
  - で、プログラミングに適したデータ構造というのは大体決まっている 配列やリストやハッシュ、というのがそれに当たると思う

## 2025/01/07
- 『教養としてのコンピュータサイエンス講義』の続きで気になっていた箇所を読むが、あまり収穫はなかった
- まあでもずっと積読してしまっていたのが一つ消化できただけでもよしとする
- 全部は読み切ってないので時が来たらまた読もうと思う

## 2025/01/06
- 『教養としてのコンピュータサイエンス講義』を年末年始にパラパラめくっていたら良さそうだったので読んでみている
- 特に今後勉強したいと思っていた「ネットワーク」「インターネット」を今回は読了
  - 短い文章で本当にさわりだけど概観を知ることができたのでとても良かった
    - ここを足がかりに個別の内容を勉強するのが良さそう
  - 「プロトコルの階層化はインターネット運用の基本 詳細を隠し複雑さを制御する」というのが、ちょうど『Linuxの仕組み』を読んで思った印象と近いものがあり、なんか感動した
- 各章にまとめがあることに後から気づいたので、残りの気になっている部分はまとめから読もうと思う

## 2025/01/05
- 『スーパーエンジニアへの道　技術リーダーシップの人間学』を斜め読みしたので感想メモ
  - 色々やらかした経験があり、だからこそ身に染みる点がいくつかあった
    - 恥ずかしくなるけど一回やらかしたからこそ実感を持って読めるのだ...と自分を納得させることにする
    - やらかしの経験からエピローグが一番沁みた
  - まず何より自分自身を成長させる・成熟させる習慣づくりが大切やな、と思う
    - 5分でいいので日誌をつけることから始める 自分自身についてメタ認知する
    - リフレーミングとかそういう話が近いのかなと思った
    - スキルの成長ではなく人間としての成熟、というのがポイントだと思う
  - リーダーシップは人々が力付与されるようなプロセスを生み出す・環境を作ること
    - 決断をするのが仕事の主要な部分ではない
    - そのために変化を起こす必要がある そこで役立つのがMOIモデル（動機づけ・組織化・アイデアの流通）
      - いつか役立ちそうなので覚えておく
      - 観察することも大事
  - 自分が成熟してないとリーダーにはなれないのは大いに同意するところ（それで自分が失敗したので）
    - 人間自分を扱う以上に他人を扱うことはできない、ということなんやなあとしみじみ
  - 斜め読みしたのですぐに目に留まらない章は読み飛ばしてしまったけど、何回か読むことでその時に感じることや発見することが変わりそうな気がする 次読むときはじっくりと読みたい
  - 『リーダーシップの旅』も似たようなことを言っていた感がする（リードザセルフ・バルコニーに上がる的な話・階層的リーダーシップとかとか）
  - 自分に対してはリーダーになりたいとは思わないし、そう思ってなるものでもない（ということが本の中で書いてある）し、リーダーになれるほど人間的に成熟してないなと思う
    - それは一旦置いておいて、今度発揮したいと思うような時が来た時のためにまずは足元の自分自身から始めようと思った