# 学習ノート
## 2025/02/20
- 『安全なWebアプリケーションの作り方』を下読みした
  - ざっと読んだ感じ 以下が脆弱性が生まれるポイント・観点なイメージ
    - 外部からの入力から攻撃する
      - ちゃんとエスケープ処理する、などで対処
    - 状態を盗み出す
      - セキュアな情報を極力状態として保たせない、などで対処
    - データが漏れる
      - 公開範囲や生存期間の調整、などで対処
  - 上記を頭に入れつつ開発すると良さそう
  - Railsアプリケーションを開発する分にはBrakemanが普段使いのチェックとしては良さそうな感じもある

## 2025/02/15
- 『改定新版 プロになるためのWeb技術入門』を下読みした
  - 下読み段階なのでGoでの実装例は今回やらなかったけど、深く理解したいときに手を動かすとすごい理解が深まりそう
  - WWWの発展の歴史は今後の技術の変化を考える意味でも参考になりそう
    - 簡単に現状の環境に導入できる・既存の技術と接続できるようにするためにどれだけ仕様を削り柔軟性を高めるかの見極め
  - その技術を理解するためには、その技術が解決しようとした課題や実現しようとした世界観や思想を知ることが大切
  - セッション管理・認証・セキュリティ・通信（HTTP, TCP/IP）・CS・API設計・OS/カーネル 周りがカバーできてない感じがある
    - アプリケーションの機能実装はできているわけだと思うので、しばらく上記を中心に学んでいくと良さそう
  - 常に「人が見てわかる情報にする」ことと「通信量を少なくする」とのせめぎ合いを感じる
    - 先の話ではないけど技術の発展にはパフォーマンスも大切
- 本の感想ではないけど定規使いながらサクサク読んでいくのが良さそう

## 2025/01/27
- 昨日書いた単一責任の原則について『研鑽Rubyプログラミング』だとトレードオフにあるという記述があったような気がしたので調べてみる
  - 『研鑽Rubyプログラミング』ではクラスにおける単一責任の原則にはトレードオフがあるという話
  - 一方で昨日は関数における単一責任の原則の話なので、両者は対象が異なることから矛盾はしないな、と自分の中で解釈した
- そのそもの単一責任の原則の定義をWikipediaで確認してみる
  - [単一責任の原則 - Wikipedia](https://ja.wikipedia.org/wiki/%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E3%81%AE%E5%8E%9F%E5%89%87)
  - > 単一責任の原則 (たんいつせきにんのげんそく、英: single-responsibility principle) は、プログラミングに関する原則であり、モジュール、クラスまたは関数は、単一の機能について責任を持ち、その機能をカプセル化するべきであるという原則である。モジュール、クラスまたは関数が提供するサービスは、その責任と一致している必要がある。
  - 「モジュール、クラスまたは関数」とあるのでやはりこれも矛盾はしなさそう
- [単一責任の原則 - Wikipedia](https://ja.wikipedia.org/wiki/%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E3%81%AE%E5%8E%9F%E5%89%87)でトム・デマルコ『構造化分析とシステム仕様』への言及があり、ちょうど積読していたので凝集度に関する部分を読んでみる
  - まず凝集度を考える単位はモジュール（p.345「モジュールは名前のついたまとまったステートメントである」）として考えている
    - 今でいうクラスとは違い、なんらかの手続き及びそれらの集合体のように捉えていそうな感じがある
      - たぶん当時（1980年代後半）の時代背景的に、まだオブジェクト指向という考え方が一般的ではなかったせいだと思われる
      - 現代におけるモジュールや関数と捉えても良さそうな気がする
  - 「容認できる凝集度のモジュールはただ1つの作業を分担しているか、あるいは同一のデータ項目を使っていることで強く結びついているためひとまとめにできる複数の関連作業を分担しているモジュールである」（p.350）
  - モジュールの凝集度を判断する基準はモジュール名・データ結合度（p.350）
    - ここで名前づけかーとなる

## 2025/01/26
- 『WEB+DB PRESS Vol.127 リファクタリング』を読んだ
  - 結合度とか凝集度について[ここ](https://gist.github.com/wataru-arai/f3b72dd604d753915019b47b12aa8d35)で触れたけどうまいこと説明できる自信がなかったので学び直し
- 凝集度
  - 関数の役割・機能の少なさ
  - 役割が少ないほど凝集度が高い・役割が多いと凝集度が低い
  - 「単一の機能」をどう捉えるかで認識が食い違うことがありそうな気がする
    - 機能をユースケースや目的、と言い換えてもいいのかもしれない
- 結合度
  - （2つ以上の関数における）独立性
  - 独立しているほど結合度が低い・していないと結合度が高い
-
- コードだけではなくアーキテクチャの検討の基準にも使える概念
- 共通化による変更箇所の局所化 vs 論理的凝集
  - 受託開発をやっていると前者が肯定されがちな気がする（短期的なスピードによるスケジュール充足がゴールになるので）
  - 論理的な凝集を選択する根拠は将来の変更に対応するためだと思うけど、その「将来の変更がどれくらいあるの？」と聞かれると答えに窮してしまう感覚がある
    - どちらかというと、「早まった抽象化を避けよう」という呼びかけをした方が良さそうな気がする
- 論理的凝集はPRレビューしててもよく見る気がする
  - 外部に公開するメソッドを1つにしたいとかそういう理由で実装されているようなイメージ
  - フラグを渡したり型を判定したりして分岐しているなら論理的凝集ということかも
    - 「フラグ引数はアンチパターンだよね」といった方が伝わるような気がする
- 受託みたいな開発をしているかどうかで許容されるコードの形は変わりそうな気もする
- まとめ
  - まず「高凝集・低結合を目指してコードを書く」ということが目指すべき方向
  - 論理的凝集に対してはテストによる変更漏れの回避・単一責任の原則あたりがアンサーになるかも
  - DRYについては「フラグ引数はアンチパターンだよね」的なアンサーがあるかも あとは「早まった抽象化を避けよう・フィードバックを得よう」とかも
  - 前提として、開発の生産性の評価というものが必要かもしれない


## 2025/01/24
- 『Software Design 2024年9月号 GraphQLでアプリケーション開発』を読んだ
  - GraphQLの利点を質問されてうまく説明できなかったので、手元に買っておいたこの本を読んだ
- GraphQLの利点
  - 通信量の効率化
    - オーバー・アンダーフェッチを回避して必要なデータだけを取得できる
    - ユースケースベース（リソースベースではない）のREST API設計・BFFでもできないことはないが、比較して導入しやすい
  - コンポーネント指向のUI設計が可能になる
  - 型システムの恩恵を受けられる
  - 漸進的なAPIの発展が可能になる
- ついでに内部向けのGraphQL APIを開発しているが、PersistedQueryやSingedQueryについては知らなかった
  - TrustedDocumentを利用することでセキュリティ向上と利用状況の収集による安全なAPIバージョンアップを実現することができるとのこと

## 2025/01/23
- 昨日のTypeScriptの話、Rubocopとほぼ同じことしてることに気づいた
  - カスタムRubocopの作り方を調べている時に気がついた
  - Prismとかもこの関連の話なんだろうなと思い、ConnectingDotsしてきた感がある
- 『ラムダノート 型を活用した安全なアプリケーション開発』を読んだ
  - コンパイル時点で不可能な操作が検知できるのは体験として良さそうな気がする
    - 型のないRailsでテストコードを書きまくってると、どうしてもコード量が大きくなってしまい見通しが悪くなりがち
    - Railsだと特定のモデルにビジネスロジックが集中するので、そのモデルのコードを読まないとビジネスロジックの内容がわからないというのがありそう
      - ルールを型で表現することで、ルールを遵守させる強制力が生まれそう
  - こうなってくると型のある開発では状態ではなく振る舞いに対してテスト書く感じになるんだろうか
    - 何だかよくわからなくなってきた感もある

## 2025/01/22
- ラムダノート TypeScriptではじめる型システムを読む
- TypeScriptの構文から構文木を組み立ててそれをさらに型付けして安全性をチェックする、という話だった
  - 構文木というのはようは木構造のデータ構造ということだと思う
  - 何かを解析する・処理するってことはまずは適したデータ構造に落とし込むということなんだなと思う
  - 木構造すると再帰の構造が生まれて、プログラミングで処理しやすくなる 気がする
  - で、プログラミングに適したデータ構造というのは大体決まっている 配列やリストやハッシュ、というのがそれに当たると思う

## 2025/01/07
- 『教養としてのコンピュータサイエンス講義』の続きで気になっていた箇所を読むが、あまり収穫はなかった
- まあでもずっと積読してしまっていたのが一つ消化できただけでもよしとする
- 全部は読み切ってないので時が来たらまた読もうと思う

## 2025/01/06
- 『教養としてのコンピュータサイエンス講義』を年末年始にパラパラめくっていたら良さそうだったので読んでみている
- 特に今後勉強したいと思っていた「ネットワーク」「インターネット」を今回は読了
  - 短い文章で本当にさわりだけど概観を知ることができたのでとても良かった
    - ここを足がかりに個別の内容を勉強するのが良さそう
  - 「プロトコルの階層化はインターネット運用の基本 詳細を隠し複雑さを制御する」というのが、ちょうど『Linuxの仕組み』を読んで思った印象と近いものがあり、なんか感動した
- 各章にまとめがあることに後から気づいたので、残りの気になっている部分はまとめから読もうと思う

## 2025/01/05
- 『スーパーエンジニアへの道　技術リーダーシップの人間学』を斜め読みしたので感想メモ
  - 色々やらかした経験があり、だからこそ身に染みる点がいくつかあった
    - 恥ずかしくなるけど一回やらかしたからこそ実感を持って読めるのだ...と自分を納得させることにする
    - やらかしの経験からエピローグが一番沁みた
  - まず何より自分自身を成長させる・成熟させる習慣づくりが大切やな、と思う
    - 5分でいいので日誌をつけることから始める 自分自身についてメタ認知する
    - リフレーミングとかそういう話が近いのかなと思った
    - スキルの成長ではなく人間としての成熟、というのがポイントだと思う
  - リーダーシップは人々が力付与されるようなプロセスを生み出す・環境を作ること
    - 決断をするのが仕事の主要な部分ではない
    - そのために変化を起こす必要がある そこで役立つのがMOIモデル（動機づけ・組織化・アイデアの流通）
      - いつか役立ちそうなので覚えておく
      - 観察することも大事
  - 自分が成熟してないとリーダーにはなれないのは大いに同意するところ（それで自分が失敗したので）
    - 人間自分を扱う以上に他人を扱うことはできない、ということなんやなあとしみじみ
  - 斜め読みしたのですぐに目に留まらない章は読み飛ばしてしまったけど、何回か読むことでその時に感じることや発見することが変わりそうな気がする 次読むときはじっくりと読みたい
  - 『リーダーシップの旅』も似たようなことを言っていた感がする（リードザセルフ・バルコニーに上がる的な話・階層的リーダーシップとかとか）
  - 自分に対してはリーダーになりたいとは思わないし、そう思ってなるものでもない（ということが本の中で書いてある）し、リーダーになれるほど人間的に成熟してないなと思う
    - それは一旦置いておいて、今度発揮したいと思うような時が来た時のためにまずは足元の自分自身から始めようと思った
